# Фибоначчиева куча

Продолжение доклада про очередь с приоритетом

## Кто это тут такой быстрый?

Фибоначчиева куча - структура данных, реализующая очередь с
приоритетом и представляющая собой лес,
состоящий из максимальных (минимальных) куч. В отличии от большинства
нами пройденных древовидных структур, она накладывает довольно мало
ограничений на кучи: каждая нода может как иметь неограниченное
число детей, так и не иметь их вообще. И куча в этом лесе
вообще может состоять только из одного элемента. Единственное строгое
условие - соблюдение условия кучи (родитель больше (меньше) своих
потомков).

## Сравнение с другими структурами

Несмотря на это, операции `INSERT`, `MIN` и `DECREASE-KEY`
(а также `UNION`) имеют сложность $O(1)$, а операция удаления
максимального (минимального) - $O(\log n)$. Собственно графики вы уже
видели, почему бы не посмотреть на цифры?

## Откуда такая скорость?

Назревает довольно натуральный вопрос: откуда фибоначчиева куча берет
такую скорость, если почти не содержит ограничений, как например в
само-балансирующихся бинарных деревьях или в самой двоичной куче? А
ответ заключается в паре хитростей: во первых, в фибоначчиевой куче
дерево порядка $n$ имеет число нод, больше или равное n - 2 числу
фибоначчи (в силу особенностей конструкции, отсюда кстати и название),
во-вторых, фибоначчиева куча использует ленивые вычисления, то есть
будет откладывать свою "балансировку" до последнего.

## Прикольно, а как это все выглядит?

А так: (картинка фибоначчиевой кучи).

Мы здесь видим лес, вот они деревья, собраны в кучи, да, конечно,
природа Казахстана не перестает удивлять... 

Если приглядеться, то можно заметить стрелки на уровне нод. Это потому,
что все ноды на одном уровне соеденены кольцевым двусвязным
списком. Это позволяет быстро перемещаться и переставлять элементы за
O(1).

## Операции на фибоначчиевой куче

### Вставка элемента

Вставка проводится довольно просто, мы сажаем новое дерево в наш
лес. То есть, по-сути, мы создаем новую фибоначчиеву кучу, и
объединяем две кучи!

### Объединение 

Добавляем деревья из другой кучи в наш лес, и не забываем перенести
ссылку на минимальный (максимальный) элемент!

### Удаление элемента

Просто уменьшаем (увеличиваем) элемент до минимального (максимального)
значения, и выполняем операцию извлечения минимума (максимума)!

### Уменьшение (увеличение) элемента

Вот и закончились легкие операции. Увеличение элемента имеет
амортизированную сложность $O(1)$, но все далеко не так просто. Вы
могли заметить (а могли и не заметить), что некоторые вершины в
фибоначчиевой куче помечены. Эти метки нам сейчас пригодятся.

Первым делом нам нужно, собственно, уменьшить элемент. Очевидно,
свойство кучи запросто может нарушится, и если такое произошло, то нам
нужно провести обрезание текущей вершины. Операция `Cut` переставляет
вершину в основной лес, на первый уровень, и если она помечена, но
убирает с нее метку. Далее обязательно следует операция
`CascadingCut`, которая выполняется только на некорневых вершинах и
заключается в следующем: если вершина помечена, мы применяем к ней
`Cut` и следом `CascadingCut` к ее родителю; иначе, мы помечаем
вершину. После появления новых саженцев в нашем лесе, не забываем
обновить минимум.

### Извлечение минимума (максимума)

Для начала аккуратно обрежем корень нашего дерева, и все его ветки
посадим как отдельные деревья в наш лес. Ссылку на минимальный элемент
временно переставляем на соседний корень, даже если он не
минимальный. Далее начинается этап "балансировки": мы создаем массив
размером максимальной высоты дерева, и начинаем проходится от соседней
ноды далее по кольцевому связному списку, поочередно добавляя в массив
ссылки на корень с высотой, соответствующей индексу в массиве. Если
так получилось, что в массиве по этому индексу уже есть другой корень,
то эти два дерева имеют одну высоту, и мы сцепляем их друг с другом. И
мы продолжаем двигаться таким образом, пока больше не сможем сцеплять
элементы. После сцепления всех элементов не забываем обновить минимум,
и вот она, наша итоговая фибоначчиева куча!

## Посмотрим поближе?

Бенчмарки с фибоначчиевой кучей и двоичной кучей, показывая насколько
фибоначчиева куча быстрее

А теперь в гонку присоединяется еще один участник: встроенная
реализация в C#! И вы посмотрите, как она обгоняет нашего текущего
лидера!

Предыдущие бенчмарки но вместе с реализацией в C#

В чем же его секрет?

## Практическое применение

А секретов несколько. Первый даже особо и не секрет - встроенные
объекты в C# будут оптимизированы явно лучше, чем написанная на
коленке рандомная структура данных. Второй секрет: в C# используется
четверичная куча (дай бог мне правильно это перевести). Отличие от
двоичной кучи лишь в том, что каждая нода может иметь до четырех (!)
детей. И уже этого достаточно, чтобы обогнать Фибоначчиеву
кучу. Почему же я так восхвалял ее в самом начале? А вот тут и третий
секрет: несмотря на свои замечательные ассемптотические оценки
сложности, большая О скрывает за собой довольно большие
константы. Поэтому фибоначчиева куча на практике редко используется
для реализации очереди с приоритетом.

## Альтернативы?

Но не расстраивайтесь: существуют модификации фибоначчиевой кучи,
позволяющие еще больше улучшить производительность, такие как :()(),
но о них я рассказывать не буду, сами прочитайте. И на этом
заканчивается мой спектакль в двух актах, всем кто слушал спасибо, кто
не слушал пожалуйста! 

