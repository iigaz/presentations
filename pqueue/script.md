# Очередь с приоритетом

## Что это такое?

Очередь с приоритетом - абстрактный тип данных, поддерживающий две обязательные операции — добавить элемент и извлечь максимум (минимум).

Основные операции очереди с приоритетом: Enqueue и Dequeue. Но также
часто реализовывают метод Peek, позволяющий узнать максимум (минимум)
без его удаления.

## Очередь?

По названию можно подумать, что она похожа на очередь. И может быть
это частично правда, но по большей части она значительно отличается от
очереди. У каждого элемента
очереди с приоритетом есть, собственно, приоритет. Порядок элементов в
этой очереди тоже другой: элементы с высшим приоритетом (или низшим, в
зависимости от реализации) всегда находятся в начале, что дает нам
быстрый доступ к ним.

## Зачем (а главное зачем)

А, собственно, зачем? А вот зачем.

1. В первую очередь, в алгоритмах нахождения кратчайшего
   пути. Например, всем уже известная Дейгкстра чаще всего
   реализовывается именно при помощи очереди с приоритетом. К менее
   известным можно причислить A star, или а со свездочкой, который
   пользуется особенной популярностью в игроделе. Но про него вам
   в скором времени расскажет Ахмед.
2. Алгоритмы Прима и Краскала построения минимального остовного
   дерева. Оба из них уже были рассказаны, повторяться я не буду.
3. Алгоритм Хаффмана. Тоже был рассказан совсем недавно.
4. В операционных системах и микроконтроллерах для выполнения задач в
   порядке убывания приоритета.
5. В медицинских системах, для распределения ресурсов в зависимости от
   состояния пациентов.

https://www.geeksforgeeks.org/applications-priority-queue/
https://codeahoy.com/learn/priorityqueue/ch2/
https://stackoverflow.com/questions/18049847/when-would-i-use-a-priority-queue

## Реализация очереди с приоритетом на списках

Ну-с, перейдем к реализации. Начнем с простого: как насчет
использовать обычный список для этого? Так как он всегда будет
отсортирован, мы можем без задней мысли использовать двоичный поиск
для поиска места, куда бы поставить новый элемент. Но здесь возникает
проблема: чтобы выполнить вставку, нам придется передвинуть хвост
списка! А это уже будет O(n).

Хм, что мы делаем когда нам нужна быстрая вставка между элементами
списка? Правильно, используем связный список! Но стойте, тогда нам
нужно будет использовать O(n) для поиска места, куда
вставить... Похоже обычные линейные структуры нам не помогут, пора
использовать тяжелую артилерию.

## Реализация очереди с приоритетом на двоичной куче

Самый распространенный способ реализации очереди с приоритетом - это
реализация на двоичной куче. В основном потому, что из нелинейных
структур ее довольно просто написать, и она очень даже хорошо
проявляет себя на трех основных операциях. Реализацию самой кучи, я
думаю, показывать не стоит, так как вам про нее уже
рассказывали. Также очевидно, что операции Enqueue, Dequeue и Peek -
просто интерфейс для соответствующих команд Add, ExtractMax и GetMax у
двоичной кучи, поэтому их я тоже показывать не буду.

Также можно реализовать на бинарном дереве поиска. И раз уж нам по
АиСД задавали написать АВЛ-дерево, почему бы не использовать его для
реализации очереди с приоритетом? А теперь, внимательно слушающие
большой доклад Нияза, Рузана и Максима могут вспомнить, что такой
вопрос уже поднимался, и мы пришли к выводу, что операция Peek будет
работать дольше на бинарном дереве поиска - за логарифм, а не за
константу, как в случае двоичной кучи. Но что если мы просто будем
сохранять максимальные (минимальные) значения и пересчитывать их
заново за логарифм после каждого удаления этого элемента? Таким
образом, мы сведем операцию Peek на константу, а операция Dequeue по
сложности останется такой же, так как лог плюс лог равно
лог. Получается, что по сложности все операции одинаковы на обеих
реализациях, поэтому как насчет сравнить их на реальных данных?

## Бенчмарки и сравнение разных реализаций

(Бенчмарки на $1 <= N <= 10^8$ с шагом в 1000 + random(999) для методов Enqueue,
Dequeue, Peek (отдельно) и алгоритма Дейгстры на очереди, реализованной при помощи списка,
связного списка, двоичной кучи и авл-дерева)

## (Плавный переход в Фибоначчиеву кучу)

Линейные графики мешают увидеть конкуренцию дерева и кучи, поэтому
давайте уберем их (бенчмарк с такими же параметрами, но только на
алгоритме Дейгстры). Вместе с этим, в соревнование входит еще один
участник, поприветствуйте... Фибоначчиева куча! И мы видим, как она с
успехом обгоняет всех своих конкурентов! В чем же ее секрет? А это вы
узнаете на следующей презентации! (Продолжение следует...)

(Ссылка на презентацию по фибонначиевой куче)
